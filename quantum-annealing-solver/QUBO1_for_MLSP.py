import neal
from pyqubo import Array, Placeholder, Binary
from pprint import pprint
from dwave.system import EmbeddingComposite, DWaveSampler, LeapHybridSampler
from math import log
import pandas as pd
from collections import defaultdict
import matplotlib.pyplot as plt
import time
from minorminer import minorminer, find_embedding
import os
import pickle
import re

# This program implements the first QUBO presented, which uses one-hot encoding. The assumptions under which the Multi-
# League Scheduling Problem is solved can be found in the paper. The QUBO is solved using either simulated annealing, quantum annealing
# or the hybrid solver provided by D-Wave, depending on the choice of the user. The results are outputed to a file by choice of the user.

# File to read data from
filename = input("From what file should the data be imported? ")

# This changes the working directory to the folder containing all the problem instances generated by the Data Generator
os.chdir("../data")

# Read data into a list of integers
with open(filename) as f:
    file = f.read()
    integers_as_strings = re.split(r'[\t\n ]+', file)
    integers_as_strings = list(filter(None, integers_as_strings))
    data = [int(i) for i in integers_as_strings]

# From this list we take out the values for the corresponding variables as specified 
num_teams = data[0]
num_leagues = data[1]
num_clubs = data[2]
league_size = data[3]               # Note that the number of HAPset is equal to this
# We can calculate the number of rounds based on the league size
num_rounds = 2*(league_size - 1)

# Initiate lists 
club_sizes = []
club_capacities = []
clubs = []
leagues = []
U = []

#Start from index 4 in the data list
index = 4
for i in range(num_clubs):
    club_size = data[index]
    index += 1
    club_cap = data[index]
    index += 1
    club_sizes.append(club_size)
    club_capacities.append(club_cap)
    club_teams = []
    for j in range(club_size):
        club_teams.append(data[index] - 1)      # Correct team numbering to take on values from 0 up to (num_teams - 1)
        index += 1
    clubs.append(club_teams)

for i in range(num_leagues):
    league_number = data[index]
    index += 1
    league = []
    for j in range(league_size):
        league.append(data[index] - 1)          # Again correct team numbering
        index += 1
    leagues.append(league)

for i in range(league_size):
    U_row = []
    for j in range(num_rounds):
        U_row.append(data[index])
        index += 1
    U.append(U_row)

# This for loop already calculates the penalty value for lambda 1, 2 and 4
penalty_value = 0
for c in range(num_clubs):
    temp = (club_sizes[c] - club_capacities[c]) ** 2
    if temp > penalty_value:
        penalty_value = temp

# Potentially rescale penalty value by a factor (normally 1):
rescale = 1
penalty_value = rescale*penalty_value

print("File has been read...")

start_time = time.time()
# Now, the QUBO is created that uses one-hot encoding, for which 4 different penalty coefficients are initiated
lambda1 = Placeholder('lambda1')
lambda2 = Placeholder('lambda2')
lambda3 = Placeholder('lambda3')
lambda4 = Placeholder('lambda4')

# Create the x decision variables as specified in the thesis (that is, for each team t and each HAPset h)
xVar = Array.create('xVar', shape = (num_teams, league_size), vartype = 'BINARY')

# Create the z auxiliary variable as specified in the thesis (that is, for each club and round, for values from 0 up to the capacity of the club)
# As the capcities of the club differ, first the matrix of z is defined
zVar = []
for c in range(num_clubs):
    club_matrix = []
    for r in range(num_rounds):
        round_array = []
        for v in range(club_capacities[c] + 1):
            round_array.append(None)
        club_matrix.append(round_array)
    zVar.append(club_matrix)

# Now in this matrix, each entry is defined as a binary variable
for c in range(num_clubs):
    for r in range(num_rounds):
        for v in range(club_capacities[c] + 1):
            zVar[c][r][v] = Binary(f'zVar[{c}][{r}][{v}]')

# Now the penalty functions for the QUBO can be defined using the variables

# Penalty 1: this penalty function mimics the first constraint of the MILP for the Multi-League Scheduling Problem
penalty1 = sum(sum(((1 - sum(xVar[t][h] for t in leagues[l])) ** 2) for h in range(league_size)) for l in range(num_leagues))

# Penalty 2: Likewise this is the penalty function that mimics the second constraint of the MILP
penalty2 = sum(sum(((1 - sum(xVar[t][h] for h in range(league_size))) ** 2) for t in leagues[l]) for l in range(num_leagues))

# Penalty 3: This penalty function uses the auxiliary variable from one-hot encoding to offset negative values for the difference in 
#            number of matches scheduled at a club in a round and its club capacity. Moreover, positive values for this difference (that is capacity violations)
#            are penalized.
penalty3 = sum(sum(((sum(zVar[c][r][v]*v for v in range(club_capacities[c] + 1)) + ((sum(sum(xVar[t][h]*U[h][r] for h in range(league_size)) for t in clubs[c]) - club_capacities[c]))) ** 2) for r in range(num_rounds)) for c in range(num_clubs))

# Penalty 4: This penalty function enforces that the one-hot encoding
penalty4 = sum(sum(((1 - sum(zVar[c][r][v] for v in range(club_capacities[c] + 1))) ** 2) for r in range(num_rounds)) for c in range(num_clubs))

# Together the penalties form the QUBO with the corresponding penalty coefficients
H = lambda1*penalty1 + lambda2* penalty2 + lambda3*penalty3 + lambda4*penalty4
model1 = H.compile()

# These values are given to the penalty coefficients from the first lambda to the last one respectively
A = penalty_value
B = penalty_value
C = 1
D = penalty_value
qubo, offset = model1.to_qubo(feed_dict = {"lambda1" : A, "lambda2" : B, "lambda3" : C, "lambda4" : D})

print("QUBO has been created...")

# Now, the QUBO can be solved using either simulated annealing, quantum annealing or the hybrid solver provided by D-Wave
if False:
    sampler = neal.SimulatedAnnealingSampler()
    response = sampler.sample_qubo(qubo, num_sweeps = 1000, num_reads = 100)       # 100 samples are created to find the best solution from
    #os.chdir()   # change working direction for output
    #fileOUT = "SA-QUBO1-Sol-" + filename

if True:
    sampler = DWaveSampler(solver=dict(topology__type='pegasus'))
    embedding = EmbeddingComposite(sampler)
    response = embedding.sample_qubo(qubo, num_reads = 2000, annealing_time = 200)                   
    #os.chdir()   # change working direction for output
    fileOUT = "QA-QUBO1-Sol-" + filename

if False:
    sampler = LeapHybridSampler()
    response = sampler.sample_qubo(qubo)
    #os.chdir()   # change working direction for output
    fileOUT = "HS-QUBO1-Sol-" + filename

samples = response.samples()
solution = response.first                   # Obtain the best solution from all samples
solution_sample = solution.sample           # Obtain the values for the decision variables from the best sample

end_time = time.time()
print("Solution is found...")
running_time = end_time - start_time
#print(f"Solution is ouputted to file: {fileOUT}")

# Manually calculate the number of violations from the solution
total_violations = 0
for c in range(num_clubs):
    for r in range(num_rounds):
        expr = sum(sum((solution_sample[f'xVar[{t}][{h}]']*U[h][r]) for h in range(league_size)) for t in clubs[c]) - club_capacities[c]
        num_violation = max(0, expr)                            # The number of violation is either equal to 0 or the expression
        total_violations = total_violations + num_violation

print(f"The total amount of violations is: {total_violations}")
print(f"The running time is: {running_time} seconds")

# Manually, calculate penalty values that follow from the QUBO and the solution for it
pen1 = sum(sum(((1 - sum(solution_sample[f'xVar[{t}][{h}]'] for t in leagues[l])) ** 2) for h in range(league_size)) for l in range(num_leagues))
pen2 = sum(sum(((1 - sum(solution_sample[f'xVar[{t}][{h}]'] for h in range(league_size))) ** 2) for t in leagues[l]) for l in range(num_leagues))
pen3 = sum(sum(((sum(solution_sample[f'zVar[{c}][{r}][{v}]']*v for v in range(club_capacities[c] + 1)) + ((sum(sum(solution_sample[f'xVar[{t}][{h}]']*U[h][r] for h in range(league_size)) for t in clubs[c]) - club_capacities[c])))) ** 2 for r in range(num_rounds)) for c in range(num_clubs))
pen4 = sum(sum(((1 - sum(solution_sample[f'zVar[{c}][{r}][{v}]'] for v in range(club_capacities[c] + 1))) ** 2) for r in range(num_rounds)) for c in range(num_clubs))
total_energy = A*pen1 + B*pen2 + C*pen3 + D*pen4
print(f"Penalty1: {pen1}, Penalty2: {pen2}, Penalty3: {pen3}, Penalty4: {pen4}, Total Energy: {total_energy}")

# Output the solution to the chosen file
with open(fileOUT, 'w') as f:
    f.write(f"The total amount of violations is: {total_violations}")
    f.write("\n")
    f.write(f"The total running time is: {running_time} seconds.")
    f.write("\n")
    f.write(f"The penalty function is rescaled by a facor of: {rescale}")
    f.write("\n")
    f.write(f"Penalty 1: {pen1}, Penalty 2: {pen2}, Penalty 3: {pen3}, Penalty4: {pen4}, Total Energy: {total_energy}")
    f.write("\n")
    f.write("\n")
    f.write("The assignment of teams to HAPs is as follows:")
    f.write("\n")
    for t in range(num_teams):
        for h in range(league_size):
            if solution_sample[f'xVar[{t}][{h}]'] == 1:
                f.write(f"Team {(t + 1)} is assigned to HAP {(h + 1)} \t")
        f.write("\n")

    